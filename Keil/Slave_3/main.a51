;	15 FEB 2025
;	FOR BLENDI HUSAJ

;-------------------------- MODBUS ------------------------------
MODBUS_SLAVE_ID EQU 3

;0x70 TO 0x77 IS ALLOTED TO INPUT REGISTER (READ ONLY)
MODBUS_VAR_INPUT_START_ADDR EQU 70H
MODBUS_VAR_INPUT_END_ADDR EQU 77H
	
;0x78 TO 0x7F IS ALLOTED TO HOLDING REGISTER (READ/WRITE)
MODBUS_VAR_HOLD_START_ADDR EQU 78H
MODBUS_VAR_HOLD_END_ADDR EQU 7FH

;0x28 TO 0x2B IS ALLOTED TO INPUT COIL (READ ONLY)
MODBUS_VAR_COIL_INPUT_START_ADDR EQU 28H
MODBUS_VAR_COIL_INPUT_END_ADDR EQU 2BH
BTN_STATE_MODBUS EQU 28H.0
BTN_STATE_MAX_MODBUS EQU 28H.1
	
;0x2C TO 0x2F IS ALLOTED TO COIL (READ/WRITE)
MODBUS_VAR_COIL_START_ADDR EQU 2CH
MODBUS_VAR_COIL_END_ADDR EQU 2FH
;----------------------------------------------------------------

;REGISTERS USED
;ACC
;R0 IS USED TO SERIAL COMM
;R2 IS USED TO INDICATE TOTAL SERIAL BYTES IN SERIAL COMM
;R4 R5 AND R6 ARE TEMP REGISTERS WHICH CAN BE USED IN SUBROUTINES
;0x30 ARE USED IN SOFTDELAY SUBROUTINE
;0x31 AND 0x32 IS USED IN PERFORM_TASK ROUTINE
;0x33 IS THE TEMP COUNTER USED IN DELAY CALCULATION
;0x34 BACKUP REGISTER USED TO BACKUP ACC VALUE IN ISR
;0x78 STORES THE PWM VALUE
;0x20.0 INDICATES SERIAL EVENT OCCURRED. MUST BE CLEARED IN SOFTWARE
;0x20.1 IS USED TO BACKUP FLAG IN ISR
;0x40 TO 0x4FH IS RESERVED FOR SERIAL BUFFER WITH R0 AS THE SERIAL BUFFER POINTER
CRC_L  EQU 50H
CRC_H  EQU 51H
	
TEMP_PWM_COUNTER EQU 33H
PWM_VAL EQU 78H
	
;MODBUS CRC POLYNOMIAL
CRC_MASK_LSB		EQU 001H
CRC_MASK_MSB 		EQU 0A0H

SERISRFLG EQU 20H.0
TOTAL_SER_BYTES EQU R2
SERIAL_BUF_START_ADDR EQU 40H
SERIAL_BUF_SIZE EQU 0FH

COM_CTRL EQU P3.2
PWM_OUT EQU P3.3
KEY EQU P3.7
PWM_VAL_PORT EQU P2
;------------------------------------------------------------------


ORG 0H
LJMP START

ORG 1BH
LCALL PWM_ISR
RETI

;SERIAL INTERRUPT
ORG 23H
LCALL SERIAL_ISR
RETI



ORG 100H
SERIAL_ISR:
	MOV 34H, A; BACKUP ACC
	MOV 20H.1, C; BACKUP CARRY FLAG
;------------ PERFORM OPERATION ON RECEPTION HERE ------------------
	JB TI, SERIAL_ISR_TX;IGNORE THE BELOW OPERATION FOR SERIAL TRANSMISSION ISR
	MOV A, SBUF;GET THE DATA IN ACC
	
	CLR RI;CLEAR RI FLAG

	CJNE TOTAL_SER_BYTES, #SERIAL_BUF_SIZE, SERIAL_ISR_STORE_BUF
	;PROGRAM CAME HERE WHICH INDICATES SERIAL BUFF IS FULL. IGNORE THE RECEIVED BYTE
	MOV P1, #55H
	RET

	SERIAL_ISR_STORE_BUF:
	MOV @R0, A
	INC R0
	INC TOTAL_SER_BYTES; INC SERIAL BYTES
	SETB SERISRFLG;SET SERIAL INDICATOR FLAG

	LJMP SERIAL_ISR_COMPLETE
	;RET
;------------------ BELOW PROGRAM IS FOR SERIAL TRANSMISSION --------------------
	SERIAL_ISR_TX:
		CLR TI;CLEAR THE FLAG
		DJNZ TOTAL_SER_BYTES, SERIAL_BUF_SEND_DAT
		;PROGRAM CAME HERE, SERIAL TX IS COMPLETE
		SETB SERISRFLG
		RET
		
		SERIAL_BUF_SEND_DAT:
		INC R0
		MOV SBUF, @R0
		;RET
		
	SERIAL_ISR_COMPLETE:
	MOV A, 34H; RESTORE ACC
	MOV C, 20H.1; RESTORE CARRY FLAG
	RET

;----------------------- PERFORM PWM OPERATION --------------------------------
PWM_ISR:
	MOV 34H, A; BACKUP ACC
	MOV 20H.1, C; BACKUP CARRY FLAG
	;-----------------------
	MOV A, TEMP_PWM_COUNTER
	INC A
	MOV TEMP_PWM_COUNTER , A
	CJNE A, #0, PWM_ISR_CYCLE_INCOMP
	;PROGRAM CAME HERE. RESET THE WAVEFORM TO HIGH
	SETB PWM_OUT
	
	PWM_ISR_CYCLE_INCOMP:
	CLR C
	SUBB A, PWM_VAL
	JC PWM_ISR_CYCLE_COMP
	;PROGRAM CAME HERE, MAKE THE WAVEFORM LOW
	CLR PWM_OUT
	
	PWM_ISR_CYCLE_COMP:
	;-----------------------
	MOV A, 34H; RESTORE ACC
	MOV C, 20H.1; RESTORE CARRY FLAG
	RET

	
START:
	MOV R0, #SERIAL_BUF_START_ADDR; INIT R0 POINTER WITH SERIAL BUFF LOCATION
	SETB EA;ENABLE ALL INTERRUPTS

	;INIT THE SERIAL HARDWARE
	SETB ES;ENABLE SERIAL INTERRUPTS
	MOV SCON, #0D0H; MODE 3 9BIT UART
	;TIMER 2 FOR GENERATING BAUD RATE
	;CRYSTAL FREQ: 11.0592 MHZ
	;CALCULATED RCAP2H & RCAP2L VALUES FOR 9600 BAUD RATE IS 1996
	MOV 0CBH, #0FFH; RCAP2H
	MOV 0CAH, #0DCH; RCAP2L
	MOV 0C8H, #030H; T2CON	
	SETB 0C8H.2; START THE TIMER 2
	;SERIAL INIT COMPLETE
	
	;INIT TIMER 1 FOR PWM OPERATION
	MOV TEMP_PWM_COUNTER, #0; CLEAR TEMP COUNTER
	MOV PWM_VAL, #0
	
	MOV TMOD, #20H; 8BIT AUTORELOAD TIMER
	MOV TH1, #200
	MOV TL1, #200
	SETB ET1; TIMER 1 OVERFLOW INTERRUPT
	SETB TR1; START THE TIMER1
	;PWM INIT COMPLETE
	
	REPEAT_OPER:
	CLR SERISRFLG
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV TOTAL_SER_BYTES, #0
	CLR COM_CTRL;ENABLE RS485 DRIVER RECEIVE
	
	PERFORM_TASK:
	MOV A, #1 ;1ms DELAY
	LCALL SOFTDELAY
	;PERFORM OTHER OPERATIONS HERE.
	;AFTER EACH OPERATION IS COMPLETE, SERIAL RECEPTION IS CHECKED. IF BYTES ARE RECEIVED FROM THE MASTER
	;SERIAL ROUTINE WILL START
	;CREATE A TIMER WHICH OVERFLOWS EVERY 23us.
	;IN THE TIMER OVF ISR, A TEMP COUNTER OF 255 STATES WILL BE USED. WHEN THIS COUNTER OVF, THE WAVEFORM CYCLE IS COMPLETED
	;PWM WILL BE MAINTAINED BY ANOTHER REGISTER WHICH COMPARES ITS VALUE WITH THIS TEMP COUNTER AND IF THE VALUE IS SAME,
	;THE WAVEFORM SHOULD BECOME LOW, AND AT EVERY TEMP COUNTER OVF, WAVEFORM SHOULD DEFAULT TO HIGH
	JB KEY, CHECK_SERIAL_FLG; IF KEY IS NOT SET, IGNORE PWM UPDATION FROM P2 DIP SW
	;UPDATE PWM VALUE FROM P2 DIP SW
	MOV PWM_VAL, PWM_VAL_PORT
	
	CHECK_SERIAL_FLG:
	JNB SERISRFLG, PERFORM_TASK;WAIT FOR SERIAL TO COMPLETE
	
	;-------------------------------------------------------
	WAIT_FOR_RX_TO_COMPL:
	CLR SERISRFLG
	MOV A, #3 ;3ms DELAY
	LCALL SOFTDELAY
	JB SERISRFLG, WAIT_FOR_RX_TO_COMPL
	MOV R0, #SERIAL_BUF_START_ADDR;RESET SERIAL BUF POINTER
	;RX COMPLETED
	
	;MOV TOTAL_SER_BYTES, #3
	;MOV @R0, #53H
	;INC R0
	;MOV @R0, #55H
	;MOV R0, #SERIAL_BUF_START_ADDR
	
	;------------------ MODBUS COMMAND RECEIVED FROM MASTER ----------------------
	;DATA IS PRESENT IN R0 POINTER. TOTAL BYTES RECEIVED ARE PRESENT IN TOTAL_SER_BYTES
	
	;CHECK IF SLAVE ID MATCHES
	;CHECK FOR CRC ERROR. IF ERROR IS PRESENT, RETURN NACK
	;CHECK IF MODBUS COMMAND IS VALID, ELSE RETURN NACK
	;IF READ OPERATION IS TO BE PERFORMED, RETURN THE READ BYTES
	;IF WRITE OPERATION IS TO BE PERFORMED, RETURN THE WRITE BYTES
	
	;CONSTRUCT THE PACKET IN R0 WITH TOTAL BYTES IN TOTAL_SER_BYTES. JUMP TO MODBUS REPLY LABEL TO
	;SEND THE PACKET BACK TO THE MASTER
	MOV R0, #SERIAL_BUF_START_ADDR
	
	MOV A, @R0
	CJNE A, #MODBUS_SLAVE_ID, REPEAT_OPER
	;SLAVE ID MATCHES
	;CHECK FOR CRC ERRORS
	MOV A, TOTAL_SER_BYTES; GET THE TOTAL BYTES LENGTH
	SUBB A, #2
	MOV TOTAL_SER_BYTES, A
	LCALL CRC_CALC
	
	MOV A, @R0
	CJNE A, CRC_L, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, CRC_H, ILLEGAL_ADDR
	
	;IF PROGRAM COMES HERE, CRC HAS PASSED
	
	MOV R0, #SERIAL_BUF_START_ADDR
	
	;IF BTN IS CLR THEN SEND NACK, STATING PWM WILL BE SET BY DIP SW
	JNB KEY, ILLEGAL_FUNC; SEND ILLEGAL FUNC ERROR
	
	;PERFORM MODBUS OPERATION HERE
	;SLAVE ONLY SUPPORTS WRITE SINGLE REGISTER. IF ANY OTHER REQUEST COMES, SEND NACK
	INC R0
	MOV A, @R0
	CJNE A, #06H, ILLEGAL_FUNC
	
	;NOW CHECK IF START ADDRESS IS VALID
	;SLAVE ONLY SUPPORTS COIL ADDRESS 0
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	
	;-------------- VALID REQUEST RECEIVED ---------------------
	;GET THE NEW PWM VALUE FROM MASTER
	INC R0; SKIP UPPER BYTE AS 8BIT VALUE ONLY SUPPORTED BY SLAVE
	INC R0
	MOV PWM_VAL, @R0
	;---- COMPLETED ------
	;SEND THE SAME REQUEST AS RESPONSE
	
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY
	;-----------------------------------------------------------
	
	ILLEGAL_FUNC:
	MOV TOTAL_SER_BYTES, #3
	MOV R0, #SERIAL_BUF_START_ADDR
	
	MOV @R0, #MODBUS_SLAVE_ID; SLAVE ID
	
	INC R0
	MOV A, @R0
	ADD A, #80H
	MOV @R0, A; ILLEGAL CODE. FUNC CODE REQUESTED + 80H
	
	INC R0
	MOV @R0, #01H ;ILLEGAL FUNC CODE
	
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY
	
	ILLEGAL_ADDR:
	MOV TOTAL_SER_BYTES, #3
	MOV R0, #SERIAL_BUF_START_ADDR
	
	MOV @R0, #MODBUS_SLAVE_ID; SLAVE ID
	
	INC R0
	MOV A, @R0
	ADD A, #80H
	MOV @R0, A; ILLEGAL CODE. FUNC CODE REQUESTED + 80H
	
	INC R0
	MOV @R0, #02H ;ILLEGAL DATA ADDRESS
	
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY

	;-----------------------------------------------------------------------------
	
	MODBUS_REPLY:
	MOV A, #20 ;20ms DELAY
	LCALL SOFTDELAY
	
	LCALL CRC_CALC
	MOV @R0, CRC_L
	INC R0
	MOV @R0, CRC_H
	MOV A, TOTAL_SER_BYTES
	ADD A, #2; CRC ADDED
	MOV TOTAL_SER_BYTES, A
	MOV R0, #SERIAL_BUF_START_ADDR
	
	CLR SERISRFLG
	SETB COM_CTRL;ENABLE RS485 DRIVER OUTPUT
	MOV SBUF, @R0
	JNB SERISRFLG, $;WAIT FOR SERIAL TO COMPLETE
		
	CANCEL_OPER:
	LJMP REPEAT_OPER
	
	;-----
	SJMP $
		
		
;CALL THIS SUBROUTINE TO CALCULATE THE CRC
;R0 SHOULD BE INITIALIZED TO ADDRESS IN RAM WHERE DATA IS STORED
;TOTAL_SER_BYTES SHOULD HAVE TOTAL BYTES TO BE READ FROM RAM
CRC_CALC:
	;LOAD TOTAL BYTES
	MOV A, TOTAL_SER_BYTES
    MOV R4, A
	
	;INIT CRC TO 0xFFFF
	MOV CRC_L,#0FFH
	MOV CRC_H,#0FFH
	
	PROCESS_BYTE:
	MOV A,@R0
	XRL A,CRC_L
	MOV CRC_L,A
	MOV R5,#8
	PROCESS_BIT:
	MOV A,CRC_H
	CLR C
	RRC A
	MOV CRC_H,A
	MOV A,CRC_L
	RRC A
	MOV CRC_L,A
	JNC NEXT_PROCESS
	MOV A,CRC_L
	XRL A,#CRC_MASK_LSB
	MOV CRC_L,A
	MOV A,CRC_H
	XRL A,#CRC_MASK_MSB
	MOV CRC_H,A
	NEXT_PROCESS:
	DJNZ R5,PROCESS_BIT
	INC R0
	DJNZ R4,PROCESS_BYTE
	
	;----
	;CALCULATION COMPLETED
	RET
		
;CALL THE SUBROUTINE WITH DELAY IN ACC
;THIS SUBROUTINE WILL RETURN AFTER TOTAL DELAY IN ACC IS ELAPSED 11059
SOFTDELAY:
	MOV 30H, #2;1 CYCLE

	DJNZ 30H, $;2 CYCLES
	DJNZ 30H, $;2 CYCLES

	DEC A;1 CYCLE
	CJNE A, #0, SOFTDELAY;2 CYCLES
	
	RET
		
END