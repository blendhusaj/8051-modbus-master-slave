;	15 FEB 2025
;	FOR BLENDI HUSAJ

;-------------------------- MODBUS ------------------------------
MODBUS_SLAVE_ID EQU 2

;0x70 TO 0x77 IS ALLOTED TO INPUT REGISTER (READ ONLY)
MODBUS_VAR_INPUT_START_ADDR EQU 70H
MODBUS_VAR_INPUT_END_ADDR EQU 77H
	
;0x78 TO 0x7F IS ALLOTED TO HOLDING REGISTER (READ/WRITE)
MODBUS_VAR_HOLD_START_ADDR EQU 78H
MODBUS_VAR_HOLD_END_ADDR EQU 7FH

;0x28 TO 0x2B IS ALLOTED TO INPUT COIL (READ ONLY)
MODBUS_VAR_COIL_INPUT_START_ADDR EQU 28H
MODBUS_VAR_COIL_INPUT_END_ADDR EQU 2BH
BTN_STATE_MODBUS EQU 28H.0
BTN_STATE_MAX_MODBUS EQU 28H.1
	
;0x2C TO 0x2F IS ALLOTED TO COIL (READ/WRITE)
MODBUS_VAR_COIL_START_ADDR EQU 2CH
MODBUS_VAR_COIL_END_ADDR EQU 2FH
;----------------------------------------------------------------

;REGISTERS USED
;ACC
;R0 IS USED TO SERIAL COMM
;R2 IS USED TO INDICATE TOTAL SERIAL BYTES IN SERIAL COMM
;R3 IS USED TO DISPLAY UPDATE ROUTINE
;R4 R5 AND R6 ARE TEMP REGISTERS WHICH CAN BE USED IN SUBROUTINES
;0x30 ARE USED IN SOFTDELAY SUBROUTINE
;0x31 AND 0x32 IS USED IN PERFORM_TASK ROUTINE
;0x34 IS USED TO BACKUP ACC IN ISR
;0x35 0x36 0x37 IS USED IN HEX TO BCD SUBROUTINE
;0x20.0 INDICATES SERIAL EVENT OCCURRED. MUST BE CLEARED IN SOFTWARE
;0x20.1 IS USED TO BACKUP CARRY FLAG IN ISR
;0x40 TO 0x4FH IS RESERVED FOR SERIAL BUFFER WITH R0 AS THE SERIAL BUFFER POINTER
ADC_VAL_REG EQU 70H

CRC_L  EQU 50H
CRC_H  EQU 51H
	
;MODBUS CRC POLYNOMIAL
CRC_MASK_LSB		EQU 001H
CRC_MASK_MSB 		EQU 0A0H

SERISRFLG EQU 20H.0
TOTAL_SER_BYTES EQU R2
SERIAL_BUF_START_ADDR EQU 40H
SERIAL_BUF_SIZE EQU 0FH

COM_CTRL EQU P3.2
	
ADC_CS EQU P2.4
ADC_WR EQU P2.5
ADC_EOC EQU P2.6
ADC_RD EQU P2.7
	
DISP_DIG0 EQU P2.3
DISP_DIG1 EQU P2.2
DISP_DIG2 EQU P2.1
DISP_SEG_PORT EQU P0


;-----------------------------------------------------------------
ORG 0H
LJMP START

ORG 1BH
LCALL DISPLAY_ISR
RETI

;SERIAL INTERRUPT
ORG 23H
LCALL SERIAL_ISR
RETI



ORG 100H
;DEFINE THE HEX CHARACTERS TO BE SHOWN ON 7 SEGMENT DISPLAY
;Ref - https://en.wikichip.org/wiki/seven-segment_display/representing_letters
;TO ACCESS THIS DATA, USE MOVC A, @A + PC
	GET_HEX_PATTERN:
	INC A; GET AROUND RET
	MOVC A, @A + PC
	RET
	
ORG 103H
	;0x00 TO 0x0F ADDRESS
	DB 07EH; FOR 0
	DB 030H; FOR 1
	DB 06DH; FOR 2
	DB 079H; FOR 3
	DB 033H; FOR 4
	DB 05BH; FOR 5
	DB 05FH; FOR 6
	DB 070H; FOR 7
	DB 07FH; FOR 8
	DB 07BH; FOR 9
	DB 077H; FOR A
	DB 01FH; FOR B
	DB 04EH; FOR C
	DB 03DH; FOR D
	DB 04FH; FOR E
	DB 047H; FOR F
	
	
	
SERIAL_ISR:
	MOV 034H, A; BACKUP ACC
	MOV 20H.1, C; BACKUP CARRY FLAG
;------------ PERFORM OPERATION ON RECEPTION HERE ------------------
	JB TI, SERIAL_ISR_TX;IGNORE THE BELOW OPERATION FOR SERIAL TRANSMISSION ISR
	MOV A, SBUF;GET THE DATA IN ACC
	
	CLR RI;CLEAR RI FLAG

	CJNE TOTAL_SER_BYTES, #SERIAL_BUF_SIZE, SERIAL_ISR_STORE_BUF
	;PROGRAM CAME HERE WHICH INDICATES SERIAL BUFF IS FULL. IGNORE THE RECEIVED BYTE
	RET

	SERIAL_ISR_STORE_BUF:
	MOV @R0, A
	INC R0
	INC TOTAL_SER_BYTES; INC SERIAL BYTES
	SETB SERISRFLG;SET SERIAL INDICATOR FLAG

	LJMP SERIAL_ISR_COMPLETE
	;RET
;------------------ BELOW PROGRAM IS FOR SERIAL TRANSMISSION --------------------
	SERIAL_ISR_TX:
		CLR TI;CLEAR THE FLAG
		DJNZ TOTAL_SER_BYTES, SERIAL_BUF_SEND_DAT
		;PROGRAM CAME HERE, SERIAL TX IS COMPLETE
		SETB SERISRFLG
		RET
		
		SERIAL_BUF_SEND_DAT:
		INC R0
		MOV SBUF, @R0
		;RET
	
	SERIAL_ISR_COMPLETE:
	MOV A, 034H; RESTORE ACC
	MOV C, 20H.1; RESTORE CARRY FLAG
	
	RET


;DISPLAY WILL BE UPDATED HERE
DISPLAY_ISR:
	MOV 034H, A; BACKUP ACC
	MOV 20H.1, C; BACKUP CARRY FLAG
	;-----------------------
	
	CLR DISP_DIG0
	CLR DISP_DIG1
	CLR DISP_DIG2
	
	;MOV A, ADC_VAL_REG
	;LCALL HEX_TO_BCD;CONVERT VALUE TO BCD
	
	CJNE R3, #0, CHK_NXT_DSP0
	;DISPLAY DIGIT 0 UPDATE
	INC R3
	
	SETB DISP_DIG0
	MOV A, 35H
	LCALL GET_HEX_PATTERN
	CPL A
	MOV P0, A
	
	SJMP DISPLAY_ISR_COMP
	
	CHK_NXT_DSP0:
	CJNE R3, #1, CHK_NXT_DSP1
	;DISPLAY DIGIT 1 UPDATE
	INC R3
	
	SETB DISP_DIG1
	MOV A, 36H
	LCALL GET_HEX_PATTERN
	CPL A
	MOV P0, A
	
	SJMP DISPLAY_ISR_COMP
	
	CHK_NXT_DSP1:
	CJNE R3, #2, DISPLAY_ISR_COMP
	;DISPLAY DIGIT 2 UPDATE
	MOV R3, #0
	
	SETB DISP_DIG2
	MOV A, 37H
	LCALL GET_HEX_PATTERN
	CPL A
	MOV P0, A
	
	DISPLAY_ISR_COMP:
	
	;PERFORM ADC CONV HERE
	JB ADC_EOC, ADC_CONV_COMP
	LCALL ADC_CONV_STOP
	LCALL ADC_CONV_START
	
	ADC_CONV_COMP:
	;-----------------------
	MOV A, 034H; RESTORE ACC
	MOV C, 20H.1; RESTORE CARRY FLAG
	
	RET

	
START:
	SETB EA;ENABLE ALL INTERRUPTS
	MOV R0, #SERIAL_BUF_START_ADDR; INIT R0 POINTER WITH SERIAL BUFF LOCATION

	;INIT THE SERIAL HARDWARE
	SETB ES;ENABLE SERIAL INTERRUPTS
	MOV SCON, #0D0H; MODE 3 9BIT UART
	;TIMER 2 FOR GENERATING BAUD RATE
	;CRYSTAL FREQ: 11.0592 MHZ
	;CALCULATED RCAP2H & RCAP2L VALUES FOR 9600 BAUD RATE IS 1996
	MOV 0CBH, #0FFH; RCAP2H
	MOV 0CAH, #0DCH; RCAP2L
	MOV 0C8H, #030H; T2CON	
	SETB 0C8H.2; START THE TIMER 2
	;SERIAL INIT COMPLETE
	
	;CONFIG ADC CONTROL PINS
	SETB ADC_CS
	SETB ADC_RD
	SETB ADC_EOC
	SETB ADC_WR
	LCALL ADC_CONV_START
	MOV A, #1;1ms SOFT DELAY
	LCALL SOFTDELAY
	;ADC INIT COMPLETE
	
	;INIT TIMER 1 FOR DISPLAY OPERATION
	MOV TMOD, #20H; 8BIT AUTORELOAD TIMER
	MOV TH1, #0
	MOV TL1, #0
	SETB ET1; TIMER 1 OVERFLOW INTERRUPT
	SETB TR1; START THE TIMER1
	;DISP INIT COMPLETE
	
	REPEAT_OPER:
	CLR SERISRFLG
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV TOTAL_SER_BYTES, #0
	CLR COM_CTRL;ENABLE RS485 DRIVER RECEIVE
	
	PERFORM_TASK:
	;PERFORM OTHER OPERATIONS HERE.
	;AFTER EACH OPERATION IS COMPLETE, SERIAL RECEPTION IS CHECKED. IF BYTES ARE RECEIVED FROM THE MASTER
	;SERIAL ROUTINE WILL START
	;PERFORM ADC CONVERSION HERE.
	;LCALL UPDATE_ADC_VAL
	
	CHECK_SERIAL_FLG:
	JNB SERISRFLG, PERFORM_TASK;WAIT FOR SERIAL TO COMPLETE
	
	;-------------------------------------------------------
	WAIT_FOR_RX_TO_COMPL:
	CLR SERISRFLG
	MOV A, #3 ;3ms DELAY
	LCALL SOFTDELAY
	JB SERISRFLG, WAIT_FOR_RX_TO_COMPL
	MOV R0, #SERIAL_BUF_START_ADDR;RESET SERIAL BUF POINTER
	;RX COMPLETED
	
	;MOV TOTAL_SER_BYTES, #3
	;MOV @R0, #53H
	;INC R0
	;MOV @R0, #55H
	;MOV R0, #SERIAL_BUF_START_ADDR
	
	;------------------ MODBUS COMMAND RECEIVED FROM MASTER ----------------------
	;DATA IS PRESENT IN R0 POINTER. TOTAL BYTES RECEIVED ARE PRESENT IN TOTAL_SER_BYTES
	
	;CHECK IF SLAVE ID MATCHES
	;CHECK FOR CRC ERROR. IF ERROR IS PRESENT, RETURN NACK
	;CHECK IF MODBUS COMMAND IS VALID, ELSE RETURN NACK
	;IF READ OPERATION IS TO BE PERFORMED, RETURN THE READ BYTES
	;IF WRITE OPERATION IS TO BE PERFORMED, RETURN THE WRITE BYTES
	
	;CONSTRUCT THE PACKET IN R0 WITH TOTAL BYTES IN TOTAL_SER_BYTES. JUMP TO MODBUS REPLY LABEL TO
	;SEND THE PACKET BACK TO THE MASTER
	MOV R0, #SERIAL_BUF_START_ADDR
	
	MOV A, @R0
	CJNE A, #MODBUS_SLAVE_ID, REPEAT_OPER
	;SLAVE ID MATCHES
	;CHECK FOR CRC ERRORS
	MOV A, TOTAL_SER_BYTES; GET THE TOTAL BYTES LENGTH
	SUBB A, #2
	MOV TOTAL_SER_BYTES, A
	LCALL CRC_CALC
	
	MOV A, @R0
	CJNE A, CRC_L, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, CRC_H, ILLEGAL_ADDR
	
	;IF PROGRAM COMES HERE, CRC HAS PASSED
	
	MOV R0, #SERIAL_BUF_START_ADDR
	
	;PERFORM MODBUS OPERATION HERE
	;SLAVE ONLY SUPPORTS READ INPUT REGISTER. IF ANY OTHER REQUEST COMES, SEND NACK
	INC R0
	MOV A, @R0
	CJNE A, #04H, ILLEGAL_FUNC
	
	;NOW CHECK IF START ADDRESS IS VALID
	;SLAVE ONLY SUPPORTS ADDRESS 0
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	
	;CHECK IF NUMBER OF REGISTER REQUESTED IS 1
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, #1H, ILLEGAL_ADDR
	
	;-------------- VALID REQUEST RECEIVED ---------------------
	MOV TOTAL_SER_BYTES, #5
	MOV R0, #SERIAL_BUF_START_ADDR
	
	;RESPOND WITH COIL DATA TO MASTER
	MOV @R0, #MODBUS_SLAVE_ID; SLAVE ID
	
	INC R0
	MOV @R0, #04H; FUNCTION CODE
	
	INC R0
	MOV @R0, #02H; BYTE COUNT IS 2
	
	INC R0
	MOV @R0, #00H; HIGHER BYTE IS 0
	
	INC R0
	MOV @R0, ADC_VAL_REG; ADC VAL
	
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY
	;-----------------------------------------------------------
	
	ILLEGAL_FUNC:
	MOV TOTAL_SER_BYTES, #3
	MOV R0, #SERIAL_BUF_START_ADDR
	
	MOV @R0, #MODBUS_SLAVE_ID; SLAVE ID
	
	INC R0
	MOV A, @R0
	ADD A, #80H
	MOV @R0, A; ILLEGAL CODE. FUNC CODE REQUESTED + 80H
	
	INC R0
	MOV @R0, #01H ;ILLEGAL FUNC CODE
	
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY
	
	ILLEGAL_ADDR:
	MOV TOTAL_SER_BYTES, #3
	MOV R0, #SERIAL_BUF_START_ADDR
	
	MOV @R0, #MODBUS_SLAVE_ID; SLAVE ID
	
	INC R0
	MOV A, @R0
	ADD A, #80H
	MOV @R0, A; ILLEGAL CODE. FUNC CODE REQUESTED + 80H
	
	INC R0
	MOV @R0, #02H ;ILLEGAL DATA ADDRESS
	
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY

	;-----------------------------------------------------------------------------
	
	MODBUS_REPLY:
	MOV A, #20 ;20ms DELAY
	LCALL SOFTDELAY
	
	LCALL CRC_CALC
	MOV @R0, CRC_L
	INC R0
	MOV @R0, CRC_H
	MOV A, TOTAL_SER_BYTES
	ADD A, #2; CRC ADDED
	MOV TOTAL_SER_BYTES, A
	MOV R0, #SERIAL_BUF_START_ADDR
	
	CLR SERISRFLG
	SETB COM_CTRL;ENABLE RS485 DRIVER OUTPUT
	MOV SBUF, @R0
	JNB SERISRFLG, $;WAIT FOR SERIAL TO COMPLETE
		
	CANCEL_OPER:
	LJMP REPEAT_OPER
	
	;-----
	SJMP $
		
		
;CALL THIS SUBROUTINE TO CALCULATE THE CRC
;R0 SHOULD BE INITIALIZED TO ADDRESS IN RAM WHERE DATA IS STORED
;TOTAL_SER_BYTES SHOULD HAVE TOTAL BYTES TO BE READ FROM RAM
CRC_CALC:
	;LOAD TOTAL BYTES
	MOV A, TOTAL_SER_BYTES
    MOV R4, A
	
	;INIT CRC TO 0xFFFF
	MOV CRC_L,#0FFH
	MOV CRC_H,#0FFH
	
	PROCESS_BYTE:
	MOV A,@R0
	XRL A,CRC_L
	MOV CRC_L,A
	MOV R5,#8
	PROCESS_BIT:
	MOV A,CRC_H
	CLR C
	RRC A
	MOV CRC_H,A
	MOV A,CRC_L
	RRC A
	MOV CRC_L,A
	JNC NEXT_PROCESS
	MOV A,CRC_L
	XRL A,#CRC_MASK_LSB
	MOV CRC_L,A
	MOV A,CRC_H
	XRL A,#CRC_MASK_MSB
	MOV CRC_H,A
	NEXT_PROCESS:
	DJNZ R5,PROCESS_BIT
	INC R0
	DJNZ R4,PROCESS_BYTE
	
	;----
	;CALCULATION COMPLETED
	RET
	
;CALL THIS SUBROUTINE TO UPDATE THE ADC
ADC_CONV_START:
	;LATCH ADC ADDRESS AND START CONVERSION
	CLR ADC_CS
	CLR ADC_WR
	SETB ADC_CS
	SETB ADC_WR
	
	JNB ADC_EOC, $
	;JB ADC_EOC, $
	
	RET

;CALL THIS SUBROUTINE TO STOP THE ADC CONV AND UPDATE THE VAL IN REG
ADC_CONV_STOP:
	;GET THE CONVERSION
	CLR ADC_CS
	CLR ADC_RD
	MOV ADC_VAL_REG, P1
	SETB ADC_CS
	SETB ADC_RD
	
	MOV A, ADC_VAL_REG
	LCALL HEX_TO_BCD;CONVERT VALUE TO BCD
	RET


;CALL THE SUBROUTINE WITH DELAY IN ACC
;THIS SUBROUTINE WILL RETURN AFTER TOTAL DELAY IN ACC IS ELAPSED 11059
SOFTDELAY:
	MOV 30H, #2;1 CYCLE

	DJNZ 30H, $;2 CYCLES
	DJNZ 30H, $;2 CYCLES

	DEC A;1 CYCLE
	CJNE A, #0, SOFTDELAY;2 CYCLES
	
	RET
	
	
;======= FOR CONVERSION FROM HEX TO DECIMAL =======
	HEX_TO_BCD:
	;VALUE IN A IS CONVERTED INTO 3 DIGIT BCD AND STORED IN 0x35 (LSB), 0x36 AND 0x37 (MSB).
	MOV B, #10
	DIV AB
	MOV 035H, B; STORE THE 3 DIGIT LSB
	MOV B, #10
	DIV AB
	MOV 036H, B; STORE THE 3 DIGIT MIDDLE VAL
	MOV 037H, A; STORE THE 3 DIGIT MSB
	
	RET
		
END