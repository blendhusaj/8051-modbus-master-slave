; Processor: AT89C52
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (80C52.MCU)

;-------------------------- MODBUS ------------------------------
MODBUS_SLAVE_ID EQU 1

;0x70 TO 0x77 IS ALLOTED TO INPUT REGISTER (READ ONLY)
MODBUS_VAR_INPUT_START_ADDR EQU 70H 
MODBUS_VAR_INPUT_END_ADDR EQU 77H

;0x78 TO 0x7F IS ALLOTED TO HOLDING REGISTER (READ/WRITE)
MODBUS_VAR_HOLD_START_ADDR EQU 78H
MODBUS_VAR_HOLD_END_ADDR EQU 7FH

;0x28 TO 0x2B IS ALLOTED TO INPUT COIL (READ ONLY)
MODBUS_VAR_COIL_INPUT_START_ADDR EQU 28H
MODBUS_VAR_COIL_INPUT_END_ADDR EQU 2BH
BTN_STATE_MODBUS EQU 28H.0
BTN_STATE_MAX_MODBUS EQU 28H.1

;0x2C TO 0x2F IS ALLOTED TO COIL (READ/WRITE)
MODBUS_VAR_COIL_START_ADDR EQU 2CH
MODBUS_VAR_COIL_END_ADDR EQU 2FH
;----------------------------------------------------------------

;REGISTERS USED
;ACC
;R0 IS USED TO SERIAL COMM
;R2 IS USED TO INDICATE TOTAL SERIAL BYTES IN SERIAL COMM
;R4 R5 AND R6 ARE TEMP REGISTERS WHICH CAN BE USED IN SUBROUTINES
;0x30 ARE USED IN SOFTDELAY SUBROUTINE
;0x31 AND 0x32 IS USED IN PERFORM_TASK ROUTINE
;0x33 AND 0x34 USED FOR LED HOLD TIMER AFTER MAX STATE
;0x20.1 IS USED TO BACKUP CARRY FLAG IN ISR
;0x20.0 INDICATES SERIAL EVENT OCCURRED. MUST BE CLEARED IN SOFTWARE
;0x40 TO 0x4FH IS RESERVED FOR SERIAL BUFFER WITH R0 AS THE SERIAL BUFFER POINTER
CRC_L  EQU 50H
CRC_H  EQU 51H

;MODBUS CRC POLYNOMIAL
CRC_MASK_LSB		EQU 001H
CRC_MASK_MSB 		EQU 0A0H

SERISRFLG EQU 20H.0
TOTAL_SER_BYTES EQU R2
SERIAL_BUF_START_ADDR EQU 40H
SERIAL_BUF_SIZE EQU 0FH

COM_CTRL EQU P3.2
BTN EQU P2.0
BTN_LED EQU P2.1

ORG 0H
LJMP START

;SERIAL INTERRUPT
ORG 23H
LCALL SERIAL_ISR
RETI

ORG 100H
SERIAL_ISR:
	MOV 34H, A
	MOV 20H.1, C
	JB TI, SERIAL_ISR_TX
	MOV A, SBUF
	CLR RI
	CJNE TOTAL_SER_BYTES, #SERIAL_BUF_SIZE, SERIAL_ISR_STORE_BUF
	RET
SERIAL_ISR_STORE_BUF:
	MOV @R0, A
	INC R0
	INC TOTAL_SER_BYTES
	SETB SERISRFLG
	LJMP SERIAL_ISR_COMPLETE
SERIAL_ISR_TX:
	CLR TI
	DJNZ TOTAL_SER_BYTES, SERIAL_BUF_SEND_DAT
	SETB SERISRFLG
	RET
SERIAL_BUF_SEND_DAT:
	INC R0
	MOV SBUF, @R0
SERIAL_ISR_COMPLETE:
	MOV A, 34H
	MOV C, 20H.1
	RET

START:
	MOV R0, #SERIAL_BUF_START_ADDR
	SETB EA
	SETB ES
	MOV SCON, #0D0H
	MOV 0CBH, #0FFH
	MOV 0CAH, #0DCH
	MOV 0C8H, #030H
	SETB 0C8H.2

REPEAT_OPER:
	CLR SERISRFLG
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV TOTAL_SER_BYTES, #0
	CLR COM_CTRL

PERFORM_TASK:
	MOV A, #1
	LCALL SOFTDELAY
	JB BTN, BTN_HIGH_OFF_STATE
	SETB BTN_STATE_MODBUS
	JB BTN_STATE_MAX_MODBUS, CHECK_SERIAL_FLG
	INC 31H
	MOV A, 31H
	CJNE A, #250, CHECK_SERIAL_FLG
	MOV 31H, #0
	INC 32H
	MOV A, 32H
	CJNE A, #20, CHECK_SERIAL_FLG
	SETB BTN_STATE_MAX_MODBUS
	SETB BTN_LED
	MOV 33H, #0
	MOV 34H, #0
	SJMP CHECK_SERIAL_FLG

BTN_HIGH_OFF_STATE:
	CLR BTN_STATE_MODBUS          ; Button released (normally open button)
	JNB BTN_STATE_MAX_MODBUS, SKIP_LED_HOLD_TIMER  ; If button wasn't held for max time, skip LED hold logic
	INC 33H                       ; Increment LED hold timer (low byte)
	MOV A, 33H                    ; Load timer value into accumulator
	CJNE A, #250, SKIP_LED_HOLD_TIMER  ; If timer < 250, skip (not enough time passed)
	MOV 33H, #0                   ; Reset low byte timer to 0
	INC 34H                       ; Increment LED hold timer (high byte)
	MOV A, 34H                    ; Load high byte into accumulator
	CJNE A, #34H, SKIP_LED_HOLD_TIMER  ; If high byte < 20, skip (total time not reached)
	CLR BTN_STATE_MAX_MODBUS      ; Reset button max state (button released)
	CLR BTN_LED                   ; Turn off LED (hold time completed)
	MOV 31H, #0                   ; Clear all timers
	MOV 32H, #0                   ; (reset button press timers)
	MOV 33H, #0                   ; (reset LED hold timers)
	MOV 34H, #0                   ; (clean slate for next button press)
SKIP_LED_HOLD_TIMER:

CHECK_SERIAL_FLG:
	JNB SERISRFLG, PERFORM_TASK
	;void CHECK_SERIAL_FLG() {
    ;if (SERISRFLG == 0) {
    ;   goto PERFORM_TASK;  // Jump immediately, no loop
    ;}
    ;// If flag = 1, continue to WAIT_FOR_RX_TO_COMPL
    ;WAIT_FOR_RX_TO_COMPL();
};
WAIT_FOR_RX_TO_COMPL:
	CLR SERISRFLG
	MOV A, #3
	LCALL SOFTDELAY
	JB SERISRFLG, WAIT_FOR_RX_TO_COMPL
	MOV R0, #SERIAL_BUF_START_ADDR

	MOV A, @R0
	CJNE A, #MODBUS_SLAVE_ID, REPEAT_OPER
	MOV A, TOTAL_SER_BYTES
	SUBB A, #2
	MOV TOTAL_SER_BYTES, A
	LCALL CRC_CALC
	MOV A, @R0
	CJNE A, CRC_L, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, CRC_H, ILLEGAL_ADDR

	MOV R0, #SERIAL_BUF_START_ADDR
	INC R0
	MOV A, @R0
	CJNE A, #02H, ILLEGAL_FUNC
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CLR C
	SUBB A, #2
	JNC ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CJNE A, #0H, ILLEGAL_ADDR
	INC R0
	MOV A, @R0
	CLR C
	SUBB A, #3
	JNC ILLEGAL_ADDR

	MOV TOTAL_SER_BYTES, #4
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV @R0, #MODBUS_SLAVE_ID
	INC R0
	MOV @R0, #02H
	INC R0
	MOV @R0, #01H
	INC R0
	CLR A
	MOV C, BTN_STATE_MAX_MODBUS
	RLC A
	MOV C, BTN_STATE_MODBUS
	RLC A
	MOV @R0, A
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY

ILLEGAL_FUNC:
	MOV TOTAL_SER_BYTES, #3
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV @R0, #MODBUS_SLAVE_ID
	INC R0
	MOV A, @R0
	ADD A, #80H
	MOV @R0, A
	INC R0
	MOV @R0, #01H
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY

ILLEGAL_ADDR:
	MOV TOTAL_SER_BYTES, #3
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV @R0, #MODBUS_SLAVE_ID
	INC R0
	MOV A, @R0
	ADD A, #80H
	MOV @R0, A
	INC R0
	MOV @R0, #02H
	MOV R0, #SERIAL_BUF_START_ADDR
	LJMP MODBUS_REPLY

MODBUS_REPLY:
	MOV A, #20
	LCALL SOFTDELAY
	LCALL CRC_CALC
	MOV @R0, CRC_L
	INC R0
	MOV @R0, CRC_H
	MOV A, TOTAL_SER_BYTES
	ADD A, #2
	MOV TOTAL_SER_BYTES, A
	MOV R0, #SERIAL_BUF_START_ADDR
	CLR SERISRFLG
	SETB COM_CTRL
	MOV SBUF, @R0
	JNB SERISRFLG, $
CANCEL_OPER:
	LJMP REPEAT_OPER
	SJMP $

CRC_CALC:
	MOV A, TOTAL_SER_BYTES
	MOV R4, A
	MOV CRC_L,#0FFH
	MOV CRC_H,#0FFH
PROCESS_BYTE:
	MOV A,@R0
	XRL A,CRC_L
	MOV CRC_L,A
	MOV R5,#8
PROCESS_BIT:
	MOV A,CRC_H
	CLR C
	RRC A
	MOV CRC_H,A
	MOV A,CRC_L
	RRC A
	MOV CRC_L,A
	JNC NEXT_PROCESS
	MOV A,CRC_L
	XRL A,#CRC_MASK_LSB
	MOV CRC_L,A
	MOV A,CRC_H
	XRL A,#CRC_MASK_MSB
	MOV CRC_H,A
NEXT_PROCESS:
	DJNZ R5,PROCESS_BIT
	INC R0
	DJNZ R4,PROCESS_BYTE
	RET

SOFTDELAY:
;CALL THE SUBROUTINE WITH DELAY IN ACC
	MOV 30H, #2 ; Load 2 into memory location 30H
	DJNZ 30H, $ ; Decrement 30H, jump to the same line if 30H is not 0
	DJNZ 30H, $ ; Decrement 30H, jump to the same line if 30H is not 0
	DEC A; Decrement A
	CJNE A, #0, SOFTDELAY; if A!=0, loop back
	RET
	; 10us delay for A=1;

END
