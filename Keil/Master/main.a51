

;REGISTERS USED
;ACC
;R0 IS USED IN SERIAL COMM
;R2 IS USED TO INDICATE TOTAL SERIAL BYTES IN SERIAL COMM
;R4 R5 AND R6 ARE TEMP REGISTERS WHICH CAN BE USED IN SUBROUTINES
;0x30 ARE USED IN SOFTDELAY SUBROUTINE
;0x34 IS USED TO BACKUP ACC IN ISR
;R7 IS USED IN RECEIVE TIMEOUT CALC
;0x20.0 INDICATES SERIAL EVENT OCCURRED. MUST BE CLEARED IN SOFTWARE
;0x20.1 IS USED TO BACKUP CARRY FLAG IN ISR
;0x40 TO 0x4FH IS RESERVED FOR SERIAL BUFFER WITH R0 AS THE SERIAL BUFFER POINTER
;0x50 AND 0x51 STORES CALCULATED CRC VALUE

;------- FOR SLAVE 1----------
SLAVE_1_BTN_BYTE EQU 28H
SLAVE_1_BTN_STATE EQU 28H.0
SLAVE_1_BTN_MAX_STATE EQU 28H.1

;------- FOR SLAVE 2----------
SLAVE_2_PWM_VAL EQU 31H

CRC_L  EQU 50H
CRC_H  EQU 51H
	
;MODBUS CRC POLYNOMIAL
CRC_MASK_LSB		EQU 001H
CRC_MASK_MSB 		EQU 0A0H

SERISRFLG EQU 20H.0
TOTAL_SER_BYTES EQU R2
SERIAL_BUF_START_ADDR EQU 40H
SERIAL_BUF_SIZE EQU 0FH

COM_CTRL EQU P3.2

ORG 0H
LJMP START

;SERIAL INTERRUPT
ORG 23H
LCALL SERIAL_ISR
RETI



ORG 100H
SERIAL_ISR:
	MOV 34H, A; BACKUP ACC
	MOV 20H.1, C; BACKUP CARRY FLAG
;------------ PERFORM OPERATION ON RECEPTION HERE ------------------
	JB TI, SERIAL_ISR_TX;IGNORE THE BELOW OPERATION FOR SERIAL TRANSMISSION ISR
	MOV A, SBUF;GET THE DATA IN ACC
	
	CLR RI;CLEAR RI FLAG
	SETB SERISRFLG;SET SERIAL INDICATOR FLAG

	CJNE TOTAL_SER_BYTES, #SERIAL_BUF_SIZE, SERIAL_ISR_STORE_BUF
	;PROGRAM CAME HERE WHICH INDICATES SERIAL BUFF IS FULL. IGNORE THE RECEIVED BYTE
	RET

	SERIAL_ISR_STORE_BUF:
	MOV @R0, A
	INC R0
	INC TOTAL_SER_BYTES; INC SERIAL BYTES

	LJMP SERIAL_ISR_COMPLETE
	;RET
;------------------ BELOW PROGRAM IS FOR SERIAL TRANSMISSION --------------------
	SERIAL_ISR_TX:
		CLR TI;CLEAR THE FLAG
		DJNZ TOTAL_SER_BYTES, SERIAL_BUF_SEND_DAT
		;PROGRAM CAME HERE, SERIAL TX IS COMPLETE
		SETB SERISRFLG
		RET
		
		SERIAL_BUF_SEND_DAT:
		INC R0
		MOV SBUF, @R0
		;RET
		
	SERIAL_ISR_COMPLETE:
	MOV A, 34H; RESTORE ACC
	MOV C, 20H.1; RESTORE CARRY FLAG
	RET

	
START:
	MOV R0, #SERIAL_BUF_START_ADDR; INIT R0 POINTER WITH SERIAL BUFF LOCATION

	;INIT THE SERIAL HARDWARE
	SETB EA;ENABLE ALL INTERRUPTS
	SETB ES;ENABLE SERIAL INTERRUPTS
	MOV SCON, #0D0H; MODE 3 9BIT UART
	;TIMER 2 FOR GENERATING BAUD RATE
	;CRYSTAL FREQ: 11.0592 MHZ
	;CALCULATED RCAP2H & RCAP2L VALUES FOR 9600 BAUD RATE IS 1996
	MOV 0CBH, #0FFH; RCAP2H
	MOV 0CAH, #0DCH; RCAP2L
	MOV 0C8H, #030H; T2CON	
	SETB 0C8H.2; START THE TIMER 2
	;SERIAL INIT COMPLETE
	
	;WAIT FOR SLAVES TO INIT
	MOV A, #255
	LCALL SOFTDELAY
	MOV A, #255
	LCALL SOFTDELAY
	
	;-------------------------------------------------------------
	REPEAT_OPER:	
	LCALL SLAVE1_MODBUS_ROUTINE
	LCALL SLAVE2_MODBUS_ROUTINE
	LCALL SLAVE3_MODBUS_ROUTINE
	
	LJMP REPEAT_OPER
	;-------------------------------------------------------------
	
	;-----
	SJMP $
		
;CALL THIS SUBROUTINE TO CALCULATE THE CRC
;R0 SHOULD BE INITIALIZED TO ADDRESS IN RAM WHERE DATA IS STORED
;TOTAL_SER_BYTES SHOULD HAVE TOTAL BYTES TO BE READ FROM RAM
CRC_CALC:
	;LOAD TOTAL BYTES
	MOV A, TOTAL_SER_BYTES
    MOV R4, A
	
	;INIT CRC TO 0xFFFF
	MOV CRC_L,#0FFH
	MOV CRC_H,#0FFH
	
	PROCESS_BYTE:
	MOV A,@R0
	XRL A,CRC_L
	MOV CRC_L,A
	MOV R5,#8
	PROCESS_BIT:
	MOV A,CRC_H
	CLR C
	RRC A
	MOV CRC_H,A
	MOV A,CRC_L
	RRC A
	MOV CRC_L,A
	JNC NEXT_PROCESS
	MOV A,CRC_L
	XRL A,#CRC_MASK_LSB
	MOV CRC_L,A
	MOV A,CRC_H
	XRL A,#CRC_MASK_MSB
	MOV CRC_H,A
	NEXT_PROCESS:
	DJNZ R5,PROCESS_BIT
	INC R0
	DJNZ R4,PROCESS_BYTE
	
	;----
	;CALCULATION COMPLETED
	RET
		
		
;CALL THE SUBROUTINE WITH DELAY IN ACC
;THIS SUBROUTINE WILL RETURN AFTER TOTAL DELAY IN ACC IS ELAPSED 11059
SOFTDELAY:
	MOV 30H, #2;1 CYCLE

	DJNZ 30H, $;2 CYCLES
	DJNZ 30H, $;2 CYCLES

	DEC A;1 CYCLE
	CJNE A, #0, SOFTDELAY;2 CYCLES
	
	RET
	
;==================== SLAVE CAN BE CONTROLLED OVER MODBUS =========================	
SLAVE1_MODBUS_ROUTINE:
;A BUTTON INTERFACED. READ INPUT COIL STATUS AT LOCATION 0 TO SEE THE BUTTON STATE
;IF COIL AT LOCATION 1 IS HIGH, IT MEANS BUTTON WAS ON FOR SET AMOUNT OF TIME AND SLAVE 3
;LED SHOULD BE AT MAXIMUM INTENSITY	
	MOV TOTAL_SER_BYTES, #6
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV @R0, #01H; SLAVE ID
	INC R0
	MOV @R0, #02H; READ INPUT COIL FUNCTION CODE 
	INC R0
	MOV @R0, #00H; ADDRESS HIGH 
	INC R0
	MOV @R0, #00H; ADDRESS LOW
	INC R0
	MOV @R0, #00H; NUM OF COILS HIGH
	INC R0
	MOV @R0, #02H; NUM OF COILS LOW
	MOV R0, #SERIAL_BUF_START_ADDR
	
	LCALL MODBUS_TX
	
	MOV R0, #SERIAL_BUF_START_ADDR

	MOV A, @R0
	CJNE A, #01H, SLAVE1_MODBUS_ROUTINE_OVER
	;SLAVE ID MATCHES
	;CHECK FOR CRC ERRORS
	MOV A, TOTAL_SER_BYTES; GET THE TOTAL BYTES LENGTH
	SUBB A, #2
	MOV TOTAL_SER_BYTES, A
	LCALL CRC_CALC
	
	MOV A, @R0
	CJNE A, CRC_L, SLAVE1_MODBUS_ROUTINE_OVER
	INC R0
	MOV A, @R0
	CJNE A, CRC_H, SLAVE1_MODBUS_ROUTINE_OVER
	
	;IF PROGRAM COMES HERE, CRC HAS PASSED
	
	MOV R0, #SERIAL_BUF_START_ADDR
	
	;PERFORM MODBUS OPERATION HERE
	INC R0
	MOV A, @R0
	CJNE A, #02H, SLAVE1_MODBUS_ROUTINE_OVER
	;VALID FUNCTION CODE FOUND
	INC R0;SKIP TOTAL BYTES
	INC R0;POINT TO COIL DATA
	MOV A, @R0
	
	;DATA STORED IN ACC
	MOV SLAVE_1_BTN_BYTE, A
	;MOV P2, SLAVE_1_BTN_BYTE

SLAVE1_MODBUS_ROUTINE_OVER:
	RET


SLAVE2_MODBUS_ROUTINE:
	MOV TOTAL_SER_BYTES, #6
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV @R0, #02H; SLAVE ID
	INC R0
	MOV @R0, #04H; READ INPUT REG FUNCTION CODE 
	INC R0
	MOV @R0, #00H; ADDRESS HIGH 
	INC R0
	MOV @R0, #00H; ADDRESS LOW
	INC R0
	MOV @R0, #00H; NUM OF REG HIGH
	INC R0
	MOV @R0, #01H; NUM OF REG LOW
	MOV R0, #SERIAL_BUF_START_ADDR
	
	LCALL MODBUS_TX
	
	MOV R0, #SERIAL_BUF_START_ADDR

	MOV A, @R0
	CJNE A, #02H, SLAVE2_MODBUS_ROUTINE_OVER
	;SLAVE ID MATCHES
	;CHECK FOR CRC ERRORS
	MOV A, TOTAL_SER_BYTES; GET THE TOTAL BYTES LENGTH
	SUBB A, #2
	MOV TOTAL_SER_BYTES, A
	LCALL CRC_CALC
	
	MOV A, @R0
	CJNE A, CRC_L, SLAVE2_MODBUS_ROUTINE_OVER
	INC R0
	MOV A, @R0
	CJNE A, CRC_H, SLAVE2_MODBUS_ROUTINE_OVER
	
	;IF PROGRAM COMES HERE, CRC HAS PASSED
	
	MOV R0, #SERIAL_BUF_START_ADDR
	
	;PERFORM MODBUS OPERATION HERE
	INC R0
	MOV A, @R0
	CJNE A, #04H, SLAVE2_MODBUS_ROUTINE_OVER
	;VALID FUNCTION CODE FOUND
	INC R0;SKIP TOTAL BYTES
	INC R0;POINT TO REG DATA HIGH
	INC R0;POINT TO REG DATA LOW
	MOV A, @R0
	
	;DATA STORED IN ACC
	MOV SLAVE_2_PWM_VAL, A
	MOV P1, A

SLAVE2_MODBUS_ROUTINE_OVER:
	RET


SLAVE3_MODBUS_ROUTINE:
;WRITE TO HOLDING REGISTER AT LOCATION 0. VALUE WRITTEN WILL BE BETWEEN 0 TO 255. ACCORDINGLY\
;SLAVE 3 WILL CONTROL THE INTENSITY OF THE LED LIGHT
;IF SLAVE_1_BTN_MAX_STATE IS SET, THEN WRITE 255 TO SLAVE 3, ELSE WRITE SLAVE_2_PWM_VAL TO SLAVE 3
	MOV TOTAL_SER_BYTES, #6
	MOV R0, #SERIAL_BUF_START_ADDR
	MOV @R0, #03H; SLAVE ID
	INC R0
	MOV @R0, #06H; READ INPUT COIL FUNCTION CODE 
	INC R0
	MOV @R0, #00H; ADDRESS HIGH 
	INC R0
	MOV @R0, #00H; ADDRESS LOW
	INC R0
	MOV @R0, #00H; VALUE TO WRITE
	INC R0
	
	JB SLAVE_1_BTN_MAX_STATE, WRITE_MAX_VALUE_TO_SLAVE_3
	MOV A, SLAVE_2_PWM_VAL
	SJMP WRITE_VALUE_TO_SLAVE_3
	
	WRITE_MAX_VALUE_TO_SLAVE_3:
	MOV A, #255
	
	WRITE_VALUE_TO_SLAVE_3:
	MOV @R0, A; VALUE TO WRITE
	MOV R0, #SERIAL_BUF_START_ADDR
	
	LCALL MODBUS_TX
	
	MOV R0, #SERIAL_BUF_START_ADDR

	MOV A, @R0
	CJNE A, #03H, SLAVE1_MODBUS_ROUTINE_OVER
	;SLAVE ID MATCHES
	;CHECK FOR CRC ERRORS
	MOV A, TOTAL_SER_BYTES; GET THE TOTAL BYTES LENGTH
	SUBB A, #2
	MOV TOTAL_SER_BYTES, A
	LCALL CRC_CALC
	
	MOV A, @R0
	CJNE A, CRC_L, SLAVE1_MODBUS_ROUTINE_OVER
	INC R0
	MOV A, @R0
	CJNE A, CRC_H, SLAVE1_MODBUS_ROUTINE_OVER
	
	;IF PROGRAM COMES HERE, CRC HAS PASSED
	;SKIP CHECKING IS SLAVE HAS NACK OR ACK

	SLAVE3_MODBUS_ROUTINE_OVER:
	RET


MODBUS_TX:
	LCALL CRC_CALC
	MOV @R0, CRC_L
	INC R0
	MOV @R0, CRC_H
	MOV A, TOTAL_SER_BYTES
	ADD A, #2; CRC ADDED
	MOV TOTAL_SER_BYTES, A
	MOV R0, #SERIAL_BUF_START_ADDR
	
	CLR SERISRFLG
	SETB COM_CTRL;ENABLE RS485 DRIVER OUTPUT
	MOV SBUF, @R0
	JNB SERISRFLG, $;WAIT FOR SERIAL TO COMPLETE
		
	CLR SERISRFLG
	MOV R0, #SERIAL_BUF_START_ADDR;RESET SERIAL BUF POINTER
	CLR COM_CTRL;ENABLE RS485 DRIVER RECEIVE
	
	;CHECK RECEIVE TIMEOUT
	MOV R7, #255
	WAIT_RX:
	MOV A, R7 
	JZ RX_TIMEOUT
	MOV A, #10 ;1ms DELAY
	LCALL SOFTDELAY
	DEC R7
	JNB SERISRFLG, WAIT_RX;WAIT FOR SERIAL TO COMPLETE
	
	WAIT_FOR_RX:
	CLR SERISRFLG
	MOV A, #3 ;3ms DELAY
	LCALL SOFTDELAY
	JB SERISRFLG, WAIT_FOR_RX
	;RX COMPLETED. IGNORE NACK CHECKING
	MOV A, #100 ;100ms DELAY
	LCALL SOFTDELAY
	RET
	
	;RECEIVE TIMEOUT OCCURRED
	RX_TIMEOUT:
	MOV R0, #SERIAL_BUF_START_ADDR;RESET SERIAL BUF POINTER
	MOV @R0, #0; CHANGE SLAVE ID TO 0 SO THAT MASTER PROCESS WILL IGNORE THIS RECEPTION
	RET
	
		
END